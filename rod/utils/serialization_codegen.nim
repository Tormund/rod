import nimx/class_registry
import macros, tables
import property_desc

proc genPhantomTypeSection(typdesc: NimNode): NimNode =
    let fields = newNimNode(nnkRecList)
    for p in typdesc.propertyDescs:
        if p.hasAttr("phantom"):
            fields.add(newIdentDefs(newIdentNode(p.name), p.attributes["phantom"]))
    if fields.len > 0:
        result = newNimNode(nnkTypeSection).add(newNimNode(nnkTypeDef).add(newIdentNode("Phantom"), newEmptyNode(),
            newNimNode(nnkObjectTy).add(newEmptyNode(), newEmptyNode(), fields)))

iterator serializablePropertyDescs(typdesc: NimNode): PropertyDesc =
    for p in typdesc.propertyDescs:
        if not p.hasAttr("noserialize"):
            yield p

proc serializationKey(p: PropertyDesc): NimNode =
    if p.hasAttr("serializationKey"):
        result = copyNimTree(p.attributes["serializationKey"])
    else:
        result = newLit(p.name)

proc actualReference(p: PropertyDesc, v: NimNode): NimNode =
    let o = if p.hasAttr("phantom"): newIdentNode("phantom") else: v
    newNimNode(nnkDotExpr).add(o, newIdentNode(p.name))

proc propertyDescWithName(typdesc: NimNode, name: string): PropertyDesc =
    for p in typdesc.propertyDescs:
        if p.name == name: return p

    # TODO: The following is a hack. Instead we should get property descs from the typdesc itself
    result.name = name
    result.attributes = initTable[string, NimNode]()

proc inheritFrom(n: NimNode): NimNode =
    #todo: think about non-ref types
    if n.len > 2 and n[2].len > 0 and n[2][0].len > 1 and n[2][0][1].kind == nnkOfInherit:
        return n[2][0][1][0]

const
    sKeyed       = 0
    sSerizalize  = 1
    sBin         = 2
    sSkipPhantom = 3

macro serializeGen*(genArgs: static[array[4, bool]], procDef: untyped): untyped =
    # echo "treeRepr\n", treeRepr(procDef), "\n args ", genArgs
    result = procDef

    let args = procDef[3]
    let obj = args[1][0]
    let serObj = args[2][0]
    var typdesc = args[1][1]
    if typdesc.kind == nnkVarTy:
        typdesc = typdesc[0]
    let phantomIdent = newIdentNode("phantom")
    let phantomTyp = genPhantomTypeSection(typdesc)
    let impl = getImpl(typdesc)

    let ofType = impl.inheritFrom()
    if not ofType.isNil and ofType.hasProperties():
        let procName = procDef[0][1]
        result[6].add quote do:
            procCall `obj`.`ofType`.`procName`(`serObj`)

    if not phantomTyp.isNil and phantomTyp.kind != nnkEmpty:
        result[6].add(phantomTyp)
        let pv = quote do:
            var `phantomIdent`: Phantom
        result[6].add(pv)

        if genArgs[sSerizalize] and not genArgs[sSkipPhantom]:
            result[6].add(newCall("toPhantom", obj, phantomIdent))

    for p in typdesc.serializablePropertyDescs:
        let visitCall = newCall(ident("visit"), serObj, actualReference(p, obj))
        if genArgs[sKeyed]: visitCall.add(p.serializationKey())

        if p.hasAttr("combinedWith"):
            let p1 = typdesc.propertyDescWithName($p.attributes["combinedWith"])
            visitCall.add(actualReference(p1, obj))
            if genArgs[sKeyed]: visitCall.add(p1.serializationKey())
        result[6].add(visitCall)

    if not phantomTyp.isNil and phantomTyp.kind != nnkEmpty:
        if not genArgs[sSerizalize] and not genArgs[sSkipPhantom]:
            result[6].add(newCall("fromPhantom", obj, phantomIdent))

    if not genArgs[sSerizalize]:
        result[6].add quote do:
            when compiles(awake(`obj`)):
                if not `serObj`.disableAwake:
                    awake(`obj`)

    echo "res \n", repr(result)

template genSerializationCodeForComponent*(c: typed) =
    import rod / utils / [ bin_deserializer ]

    when defined(rodplugin):
        import rod / utils / [ json_deserializer, json_serializer,
                bin_serializer, serialization_hash_calculator ]

        bind className
        method deserialize*(v: c, b: JsonDeserializer) {.serializeGen: [ true, false, false, false ].} =
            ## generated by macro serializeGen

        method serialize*(v: c, b: JsonSerializer) {.serializeGen: [ true, true, false, false ].} =
            ## generated by macro serializeGen
            b.visit(className(v), "_c")

        method serialize*(v: c, b: BinSerializer) {.serializeGen: [ false, true, true, false ] .} =
            ## generated by macro serializeGen

        method serializationHash*(v: c, b: SerializationHashCalculator)  {.serializeGen: [ true, true, false, true ] .} =
            ## generated by macro serializeGen

    method deserialize*(v: c, b: BinDeserializer) {.serializeGen: [ false, false, true, false ] .} =
        ## generated by macro serializeGen

template genJsonSerializationrFor*(c: typed) =
    import rod / utils / [ json_deserializer, json_serializer ]

    proc serialize*(v: c, b: JsonSerializer) {.serializeGen: [ true, true, false, false ].} =
        ## generated by macro serializeGen
    when c is ref:
        proc deserialize*(v: c, b: JsonDeserializer) {.serializeGen: [ true, false, false, false ].} =
            ## generated by macro serializeGen
    else:
        proc deserialize*(v: var c, b: JsonDeserializer) {.serializeGen: [ true, false, false, false ].} =
            ## generated by macro serializeGen

    proc toJson*(v: c): JsonNode =
        var b = newJsonSerializer()
        v.serialize(b)
        result = b.node

    proc `to c`*(jn: JsonNode): c =
        var b = newJsonDeserializer()
        b.node = jn
        when c is ref:
            result.new()
        result.deserialize(b)
